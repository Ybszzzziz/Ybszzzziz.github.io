{"meta":{"title":"unqyan's blog","subtitle":"","description":"","author":"BoShuaiYan","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Leetcode2681.英雄的力量","slug":"Leetcode2681.英雄的力量","date":"2023-12-01T02:22:31.000Z","updated":"2023-12-01T08:36:00.645Z","comments":true,"path":"2023/12/01/Leetcode2681.英雄的力量/","permalink":"http://example.com/2023/12/01/Leetcode2681.%E8%8B%B1%E9%9B%84%E7%9A%84%E5%8A%9B%E9%87%8F/","excerpt":"","text":"Leetcode2681.英雄的力量2681. 英雄的力量 - 力扣（LeetCode） 1.动态规划 + 前缀和​ 考虑如何计算一个nums [i]，0 &lt; i &lt; n，由于数组已经排好序，所以以nums [i] 结尾的子序列的最大值 就是nums [i]，所以可以只考虑所有子序列的最小值之和。设dp [ j ] 表示以 nums [ j ] 结尾的所有子序 列最小值之和，得到以下式子 ​ ​ 那么以nums [i] 结尾的全部子序列的英雄组力量和为 nums [i] * nums [i] * dp [i] ​ 计算dp [i] 需要 O (n) 的复杂度，总体复杂度为 n² ，会超时。所以可以使用前缀和数组prefix 进行优化 ​ prefix [i+1] &#x3D; prefix[i] + dp[i] ​ 初始式就可以优化为： ​ 123456789101112131415161718class Solution &#123; public int sumOfPower(int[] nums) &#123; Arrays.sort(nums); int n = nums.length; // 表示以i结尾的所有子序列的最小值之和 int[] dp = new int[n]; int[] prefix = new int[n + 1]; int mod = 1000000007; int res = 0; for (int i = 0 ; i &lt; n ; i ++) &#123; dp[i] = (nums[i] + prefix[i]) % mod; prefix[i + 1] = (prefix[i] + dp[i]) % mod; res = (int)((res + (long) nums[i] * nums[i] % mod * dp[i]) % mod); if (res &lt; 0) res += mod; &#125; return res; &#125;&#125; 2.滚动数组优化版​ 因为dp [i] 和 prefix [i] 的计算只与前一个状态有关，所以可以使用滚动数组来优化 12345678910111213141516class Solution &#123; public int sumOfPower(int[] nums) &#123; Arrays.sort(nums); int dp = 0, preSum = 0; int res = 0, mod = 1000000007; for (int i = 0; i &lt; nums.length; i++) &#123; dp = (nums[i] + preSum) % mod; preSum = (preSum + dp) % mod; res = (int) ((res + (long) nums[i] * nums[i] % mod * dp) % mod); if (res &lt; 0) &#123; res += mod; &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"flume自定义拦截器","slug":"flume 自定义拦截器","date":"2023-11-30T16:00:00.000Z","updated":"2023-12-01T08:36:37.919Z","comments":true,"path":"2023/12/01/flume 自定义拦截器/","permalink":"http://example.com/2023/12/01/flume%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"flume 自定义拦截器1.自定义类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.atguigu.Interceptor;import org.apache.flume.Context;import org.apache.flume.Event;import org.apache.flume.interceptor.Interceptor;import java.util.ArrayList;import java.util.List;import java.util.Map;/** * @author Yan * @create 2023-09-11 14:13 **/public class TypeInterceptor implements Interceptor &#123; // 声明一个集合用于存放拦截器处理后的事件 private List&lt;Event&gt; addHeaderEvents; @Override public void initialize() &#123; // 初始化 addHeaderEvents = new ArrayList&lt;&gt;(); &#125; // 单个事件 @Override public Event intercept(Event event) &#123; // 1.获取body&amp;header String body = new String(event.getBody()); Map&lt;String, String&gt; headers = event.getHeaders(); // 2.根据body中是否含atguigu字符串添加不同的头信息 // 如果不包含过滤掉：return null if (body.contains(&quot;atguigu&quot;)) &#123; headers.put(&quot;type&quot;, &quot;atguigu&quot;); &#125; else &#123; return null; &#125; return event; &#125; // 多个事件 @Override public List&lt;Event&gt; intercept(List&lt;Event&gt; list) &#123; // 1.清空集合 addHeaderEvents.clear(); // 2.遍历events for (Event event : list) &#123; addHeaderEvents.add(intercept(event)); &#125; // 3.返回数据 return addHeaderEvents; &#125; @Override public void close() &#123; &#125; public static class Builder implements Interceptor.Builder &#123; @Override public Interceptor build() &#123; return new TypeInterceptor(); &#125; @Override public void configure(Context context) &#123; &#125; &#125;&#125; 2.flume配置文件12345678910111213141516171819202122232425262728# name the components on this agenta1.sources = r1a1.sinks = k1a1.channels = c1# configure the sourcea1.sources.r1.type = netcata1.sources.r1.bind = hadoop102a1.sources.r1.port = 44444a1.sources.r1.interceptors = i1a1.sources.r1.interceptors.i1.type = com.atguigu.Interceptor.TypeInterceptor$Buildera1.sources.r1.selector.type = multiplexinga1.sources.r1.selector.header = typea1.sources.r1.selector.mapping.atguigu = c1# describe the sinka1.sinks.k1.type = avroa1.sinks.k1.hostname = hadoop103a1.sinks.k1.port = 4141# channela1.channels.c1.type = memorya1.channels.c1.capacity = 1000a1.channels.c1.transactionCapacity = 100# bind source/sink to channela1.sources.r1.channels = c1a1.sinks.k1.channel = c1 3.启动服务在hadoop103启动接受信息的服务avro-flume-logger， 1[atguigu@hadoop103 flume]$ bin/flume-ng agent -c conf/ -n a1 -f job/test/net-flume-logger.conf -Dflume.root.logger=INFO,console hadoop102启动服务， 1[atguigu@hadoop102 flume]$ bin/flume-ng agent -c conf/ -n a1 -f job/test/net-flume-logger.conf 在另外一台hadoop102使用netcat向localhost发送消息， 1[atguigu@hadoop102 logs]$ nc hadoop102 44444 4.测试结果只接受到包含atguigu的消息，完成了消息的过滤 hadoop102: hadoop103:","categories":[],"tags":[]},{"title":"first_post","slug":"first-post","date":"2023-11-30T02:22:31.000Z","updated":"2023-11-30T02:22:31.846Z","comments":true,"path":"2023/11/30/first-post/","permalink":"http://example.com/2023/11/30/first-post/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-11-30T01:48:51.241Z","updated":"2023-11-30T01:48:51.241Z","comments":true,"path":"2023/11/30/hello-world/","permalink":"http://example.com/2023/11/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}